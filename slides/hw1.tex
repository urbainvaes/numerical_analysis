\documentclass[9pt]{beamer}
\usepackage{xstring}
\usepackage[cache=false,outputdir=build]{minted}
\usepackage[weather]{ifsym}

\input{header}
\input{macros}

\renewcommand{\emph}[1]{\textcolor{blue}{#1}}%
\newcommand{\emphtitle}[1]{\textcolor{yellow}{#1}}%
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}

\graphicspath{{figures/}}
\addbibresource{main.bib}

\author{Urbain Vaes}{}
\date{}

\begin{document}

\begin{frame}[fragile]
  {Babylonian square root}
\begin{minted}{julia}
function babylonian_square_root(n)
    x = rand(1:n);
    while abs(x^2-n)>0.1
        x=0.5*(x+n/x);
    end
    println("sqrt($n)=$x")
end
\end{minted}

\begin{minted}{julia}
function babylonian_square_root(n)
    x0 = 0
    x1 = n / 2
    while x1 != x0
        x0 = x1
        x1 = 0.5 * (x0 + n / x0)
    end
    return x1
end
\end{minted}
\end{frame}

\begin{frame}[fragile]
  {Euclid's algorithm}
\begin{minted}{julia}
function euclid_gcd(a, b)
    if a>=b
        m=a
        n=b
    else
        m=b
        n=a
    end
    if n==0
        return m
    end
    r = m % n
    while r != 0
        m = n
        n = r
        r = m % n
    end
    return n
end
\end{minted}
\end{frame}

\begin{frame}[fragile]
  {Euclid's algorithm}
\begin{minted}[highlightlines={2-4}]{julia}
function euclid_gcd(a, b)
    if b > a
      return euclid_gcd(b, a)
    end
    if b==0
        return a
    end
    r = a % b
    while r != 0
        a = b
        b = r
        r = a % b
    end
    return b
end
\end{minted}
\end{frame}

\begin{frame}[fragile]
  {Euclid's algorithm}
\begin{minted}[highlightlines={2}]{julia}
function euclid_gcd(a, b)
    b == 0 && return a
    r = a % b
    while r != 0
        a = b
        b = r
        r = a % b
    end
    return b
end
\end{minted}
\end{frame}

\begin{frame}[fragile]
  {Euclid's algorithm}
\begin{minted}{julia}
function euclid_gcd(a, b)
    while b != 0
        a = b
        b = r
        r = a % b
    end
    return a
end
\end{minted}

or recursively\dots
\begin{minted}{julia}
function euclid_gcd(a, b)
    b == 0 && return a
    return euclid_gcd(b, a % b)
end
\end{minted}
\end{frame}

\begin{frame}[fragile]
  {Sieve of Eratosthenes}
  \begin{minted}{julia}
  function eratosthenes_sieve(n)
    A=ones(1,n);
    A[1]=0;
    i=2;
    while i<=sqrt(n)
       count = 0;
       if A[i]==1
          while i^2+count*i<=n
             j=i^2+count*i;
             A[j]=0;
             count = count+1;
          end
       end
       i=i+1;
    end
    primes = zeros(Int, 0)
    for i=1:n
       if A[i]==1
           append!(primes, i)
       end
    end
    return primes
  end
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  {Sieve of Eratosthenes}
  \begin{minted}[highlightlines={4,12}]{julia}
  function eratosthenes_sieve(n)
    A=ones(1,n)
    A[1]=0
    for i in 2:floor(Int, sqrt(n))
       if A[i]==1
          for j in i^2:i:n
             A[j]=0
          end
       end
    end
    primes = zeros(Int, 0)
    for i=1:n
       if A[i]==1
           append!(primes, i)
       end
    end
    return primes
  end
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  {Sieve of Eratosthenes}
  \begin{minted}[highlightlines={2,6}]{julia}
  function eratosthenes_sieve(n)
    A=ones(n)
    A[1]=0
    for i in 2:floor(Int, sqrt(n))
       if A[i]==1
          A[i^2:i:n] .= 0
       end
    end
    primes = zeros(Int, 0)
    for i=1:n
       if A[i]==1
           append!(primes, i)
       end
    end
    return primes
  end
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  {Sieve of Eratosthenes}
  \begin{minted}[highlightlines={9}]{julia}
  function eratosthenes_sieve(n)
    A=ones(n)
    A[1]=0
    for i in 2:floor(Int, sqrt(n))
       if A[i]==1
          A[i^2:i:n] .= 0
       end
    end
    primes = [i for i in 1:n if A[i] == 1]
    return primes
  end
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  {Sieve of Eratosthenes}
  \begin{minted}[highlightlines={9}]{julia}
  function eratosthenes_sieve(n)
    A=ones(n)
    A[1]=0
    for i in 2:floor(Int, sqrt(n))
       if A[i]==1
          A[i^2:i:n] .= 0
       end
    end
    return findall(x -> x == 1, A)
  end
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  {Sieve of Eratosthenes}
  \begin{minted}[highlightlines={2}]{julia}
  function eratosthenes_sieve(n)
    A = ones(Bool, n)
    A[1] = false
    for i in 2:floor(Int, sqrt(n))
       if A[i]
          A[i^2:i:n] .= false
       end
    end
    return findall(A)
  end
  \end{minted}
\end{frame}

\end{document}

% vim: ts=2 sw=2 spelllang=fr spell
