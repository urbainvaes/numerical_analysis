\chapter{Brief introduction to Julia}%
\label{cha:a_very_short_introduction_to_julia}

In this chapter,
we very briefly present  some of the basic features and functions of Julia.
Most of the information contained in this chapter can be found in the online manual,
to which we provide pointers in each section.

\subsection*{Installing Julia}%
\label{sub:installing_julia}
The suggested programming environment for this course is the open-source text editor Visual Studio Code.
You may also use \emph{Vim} or \emph{Emacs},
if you are familiar with any of these.

\begin{task}
    Install Visual Studio Code.
    Install also the Julia and Jupyter Notebook extensions.
\end{task}

\subsection*{Obtaining documentation}%
\label{sub:getting_documentation}

To find documentation on a function from the Julia console,
type ``\texttt{?}'' and then the name of the function.
Tab completion is helpful for listing available function names.

\begin{task}
    Read the help pages for \julia{if}, \julia{while} and \julia{for}.
    More information on these keywords is available in the~\href{https://docs.julialang.org/en/v1/manual/control-flow/} {online documentation}.
\end{task}


\begin{remark}
    [Shorthand \julia{if} notation]
If there is no \julia{elseif} clause,
it is sometimes convenient to use the following shorthand notations instead of an \julia{if} block.
\begin{minted}{julia}
condition = true

# Assign 0 to x if `condition' is true, else assign 2
x = condition ? 0 : 2

# Print "true" if `condition' is true
condition && println("true")

# Print "false" if `condition' is false
condition || println("false")
\end{minted}
\end{remark}

% \begin{remark}
%     [Shorthand \julia{for} notation]
%     There is also a convenient shorthand notation for nested \julia{for} loops,
%     which is sometimes useful for iterating over matrix elements:
% \begin{minted}{julia}
% for greeting in ["Bonjour ", "Hello "], person in ["Alice", "Bob"]
%     println(greeting * person)
% end
% \end{minted}
% \end{remark}

\subsection*{Installing and using a package {\footnotesize \href{https://docs.julialang.org/en/v1/stdlib/Pkg/}{[link to relevant manual section]}}}%
\label{sub:installing_and_using_a_package}
To install a package from the Julia REPL (Read Evaluate Print Loop, also more simply called the Julia console),
first type ``\texttt{]}'' to enter the package REPL,
and then type \julia{add} followed the name of the package to install.
After it has been added, a package can be used with the \julia{import} keyword.
A function \julia{fun} defined in a package \julia{pack} can be accessed as \julia{pack.fun}.
For example, to plot the cosine function from the Julia console or in a script, write
\begin{minted}{julia}
    import Plots
    Plots.plot(cos)
\end{minted}

Alternatively, a package may be imported with the \julia{using} keyword,
and then functions can be accessed without specifying the package name.
While convenient, this approach is less descriptive;
it does not explicitly show what package a function comes from.
For this reason, it is often recommended to use \julia{import},
especially in a large codebase.

\begin{task}
    Install the \texttt{Plots} package,
    read the documentation of the \texttt{Plots.plot} function,
    and plot the function $f(x) = \exp(x)$.
    The tutorial on plotting available at \href{https://docs.juliaplots.org/latest/tutorial/} {this link}
    may be useful for this exercise.
\end{task}

\subsection*{Printing output}%
The functions \julia{println} and \julia{print} enable to display output.
The former adds a new line at the end and the latter does not.
The symbol \texttt{\$}, followed by a variable name or an expression within brackets,
can be employed to perform \emph{string interpolation}.
For instance, the following code prints \julia{a = 2, a^2 = 4}.
\begin{minted}{julia}
    a = 2
    println("a = $a, a^2 = $(a*a)")
\end{minted}
To print a matrix in an easily readable format,
the \julia{display} function is very useful.

\subsection*{Defining functions {\footnotesize \href{https://docs.julialang.org/en/v1/manual/functions/} {[link to relevant manual section]}}}%
\label{sub:defining_functions}
Functions can be defined using a \julia{function} block.
For example, the following code block defines a function that prints ``Hello, NAME!''.

\begin{minted}{julia}
    function hello(name)
        # Here * is the string concatenation operator
        println("Hello, " * name)
    end

    # Call the function
    hello("Bob")
\end{minted}

If the function definition is short,
it is convenient to use the following more compact syntax:
\begin{minted}{julia}
    hello(name) = println("Hello, " * name)
\end{minted}

Sometimes, it is useful to define a function without giving it a name, called an \emph{anonymous function}.
This can be achieved in Julia using the arrow notation \julia{->}.
For example, the following lines calculates the squares and cubes of the first 5 natural numbers.
Here, the function \julia{map} enables to transform a collection by applying a function to each element.
\begin{minted}{julia}
    squares = map(x -> x^2, [1, 2, 3, 4, 5])
    cubes = map(x -> x^3, [1, 2, 3, 4, 5])
\end{minted}

The \julia{return} keyword can be used for returning a value to the function caller.
Several values, separated by commas, can be returned at once.
For instance, the following function takes a number $x$ and returns a tuple $(x, x^2, x^3)$.
\begin{minted}{julia}
    function powers(x)
        return x, x^2, x^3
    end

    # This is an equivalent definition in short notation
    short_powers(x) = x, x^2, x^3

    # This assigns a = 2, b = 4, c = 8
    a, b, c = powers(2)
\end{minted}

\begin{task}
    [Euler constant for the harmonic series]
    Euler showed that
    \[
        \lim_{N \to \infty} \left( - \ln(N) + \sum_{n=1}^{N} \frac{1}{n} \right) = \gamma := 0.577...
    \]
    Write a function that returns an approximation of the Euler constant by evaluating the expression between brackets at a finite value of $N$.
    \begin{minted}{julia}
    function euler_constant(N)
        # Your code comes here
    end
    \end{minted}
\end{task}

\begin{task}
    [Tower of Hanoi]
    We consider a variation on the classic Tower of Hanoi problem,
    in which the number $r$ of pegs is allowed to be larger than 3.
    We denote the pegs by $p_1, \dots, p_r$,
    and assume that the problem includes $n$ disks with radii $1$ to $n$.
    The tower is initially constructed in~$p_1$,
    with the disks arranged in order of decreasing radius, the largest at the bottom.
    The goal of the problem is to reconstruct the tower at $p_r$ by moving the disks one at the time,
    with the constraint that a disk may be placed on top of another only if its radius is smaller.

    It has been conjectured that the optimal solution,
    which requires the minimum number of moves,
    can always be decomposed into the following three steps:
    \begin{itemize}
        \item First move the top $k$ disks of the tower to peg $p_2$;
        \item Then move the bottom $n-k$ disks of the tower to $p_r$ without using $p_2$;
        \item Finally, move the top of the tower for $p_2$ to $p_r$.
    \end{itemize}
    This suggests a recursive procedure for solving the problem, known as the Frame-Stewart algorithm.
    Write a Julia function \julia{T(n, r)} returning the minimal number of moves necessary.
% \begin{minted}{julia}
%     function T(n, r)
%         # Particular case
%         if n == 1
%             return 1
%         end
%         # Your code comes here
%     end
% \end{minted}

\end{task}

\subsection*{Local and global scopes {\footnotesize \href{https://docs.julialang.org/en/v1/manual/variables-and-scoping/}{[link to relevant manual section]}}}
Some constructs in Julia introduce scope blocks, notably \julia{for} and \julia{while} loops,
as well as \julia{function} blocks.
The variables defined within these structures are not available outside them.
For example
\begin{minted}{julia}
    if true
        a = 1
    end
    println(a)
\end{minted}
prints \julia{1},
because \julia{if} does not introduce a scope block,
but
\begin{minted}{julia}
    for i in [1, 2, 3]
        a = 1
    end
    println(a)
\end{minted}
produces \julia{ERROR: LoadError: UndefVarError: a not defined}.
The variable \julia{a} defined within the \julia{for} loop is said to be in the \emph{local scope} of the loop,
whereas a variable defined outside of it is in the \emph{global scope}.
In order to modify a global variable from a local scope,
the \julia{global} keyword must be used.
For instance, the following code
\begin{minted}{julia}
    a = 1
    for i in [1, 2, 3]
        global a += 1
    end
    println(a)
\end{minted}
modifies the global variable \julia{a} and prints 4.

\subsection*{Multi-dimensional arrays {\footnotesize \href{https://docs.julialang.org/en/v1/manual/arrays/} {[link to relevant manual section]}}}%
\label{sub:multi_dimensional_arrays}

A working knowledge of multi-dimensional arrays is important for this course,
because vectors and matrices are ubiquitous in numerical algorithms.
In Julia, a two-dimensional array can be created by writing its lines one by one,
separating them with a semicolon \julia{;}.
Within a line, elements are separated by a space.
For example,
the instruction
\begin{minted}{julia}
    M = [1 2 3; 4 5 6]
\end{minted}
creates the matrix
\[
    M =
    \begin{pmatrix}
        1 & 2 & 3 \\ 4 & 5 & 6
    \end{pmatrix}
\]
More generally,
the semicolon enables vertical concatenation
while space concatenates horizontally.
For example, \julia{[M M]} defines is the matrix
\[
    \begin{pmatrix}
        1 & 2 & 3 & 1 & 2 & 3 \\ 4 & 5 & 6 & 4 & 5 & 6
    \end{pmatrix}
\]
The expression \julia{M[r, c]} gives the $(r, c)$ matrix element of $M$.
The special entry \julia{end} can be used to access the last row or column.
For instance, \julia{M[end-1, end]} gives the matrix entry in the second to last row and the last column.
From the matrix $M$ above,
the submatrix \julia{[2  3; 5 6]} can be obtained with \julia{M[:, 2:3]}.
Here the row index \julia{:} means ``select all lines'' and the column index~\julia{2:3} means ``select columns 2 to 3''.
Likewise, the submatrix \julia{[1 3; 4 6]} may be extracted with \julia{M[:, [1; 3]]}.
\begin{remark}
    [One-dimensional arrays]
    The comma~\julia{,} can also be employed for creating one-dimensional arrays,
    but its behavior differs slightly from that of the vertical concatenation operator~\julia{;}.
    For example, \julia{x = [1, [2; 3]]} creates a \julia{Vector} object with two elements,
    the first one being \julia{1} and the second one being \julia{[1; 3]}, which is itself a \julia{Vector}.
    In contrast, the instruction \julia{x = [1; [1; 2]]} creates the same \julia{Vector} as \julia{[1; 2; 3]} would.

    We also mention that the expression \julia{x = [1 2 3]} produces not a one-dimensional \julia{Vector} but a two-dimensional \julia{Matrix},
    with one row and three columns.
    This can be checked using the \julia{size} function,
    which for \julia{x = [1 2 3]} returns the tuple \julia{(1, 3)}.
\end{remark}

There are many built-in functions for quickly creating commonly used arrays.
For example,
\begin{itemize}
    \item
        \julia{transpose(M)} gives the transpose of $M$, and \julia{adjoint(M)} or \julia{M'} gives the transpose conjugate.
        For a matrix with real-valued entries,
        both functions deliver the same result.
    \item \julia{zeros(Int, 4, 5)} creates a $4\times 5$ matrix of zeros of type \julia{Int};
    \item \julia{ones(2, 2)} creates a $2 \times 2$ matrix of ones;
    \item \julia{range(0, 1, length=101)} creates an array of size 101 with elements evenly spaced between 0 and 1 included.
        More precisely, \julia{range} returns an array-like object,
        which can be converted to a vector using the \julia{collect} function.
    \item \julia{collect(reshape(1:9, 3, 3))} creates a $3 \times 3$ matrix with elements
        \[
            \begin{pmatrix}
                1 & 4 & 7 \\
                2 & 5 & 8 \\
                3 & 6 & 9
            \end{pmatrix}
        \]
\end{itemize}
Let us also mention the following shorthand notation,
called \emph{array comprehension} for creating vectors and matrices:
\begin{itemize}
    \item \julia{[i^2 for i in 1:5]} creates the vector \julia{[1, 4, 9, 16, 25]}.
    \item \julia{[i + 10*j for i in 1:4, j in 1:4]} creates the matrix
        \[
            \begin{pmatrix}
                11  & 21  & 31  & 41 \\
                12  & 22  & 32  & 42 \\
                13  & 23  & 33  & 43 \\
                14  & 24  & 34  & 44
            \end{pmatrix}.
        \]
    \item
        \julia{[i for i in 1:10 if ispow2(i)]} creates the vector \julia{[1, 2, 4, 8]}.
        The same result can be achieved with the \julia{filter} function: \julia{filter(ispow2, 1:10)}.
\end{itemize}

\begin{task}
    Create a 10 by 10 diagonal matrix with the $i$-th entry on the diagonal equal to $i$.
\end{task}

\subsection*{Broadcasting}%
\label{sub:broadcasting}
To conclude this chapter,
we briefly discuss \emph{broadcasting},
which enables to apply functions to array elements and to perform operations on arrays of different sizes.
Julia really shines in this area,
with syntax that is both explicit and concise.
Rather than providing a detailed definition of broadcasting,
which is available in \href{https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting}{this part} of the official documentation,
we illustrate the concept using examples.
Consider first the following code block:
\begin{minted}{julia}
    function welcome(name)
        println("Hello, " * name * "!")
    end
    result = broadcast(welcome, ["Alice", "Bob"])
\end{minted}
Here \julia{broadcast} returns an array with elements \julia{"Hello, Alice!"} and \julia{"Hello, Bob!"},
as would the \julia{map} function.
Broadcasting, however, is much more flexible because it can handle arrays with different sizes.
For instance, \julia{broadcast(gcd, 24, [10, 20, 30])} returns an array of size 3 containing the greatest common divisors of the pairs $(24, 10)$, $(24, 20)$ and $(24, 30)$.
Similarly, the instruction \julia{broadcast(+, 1, [1, 2, 3])} returns \julia{[2, 3, 4]}.
To understand the latter example, note that \julia{+} (as well as \julia{*}, \julia{-} and \julia{/}) can be called like any other Julia functions;
the notation \julia{a + b} is just syntactic sugar for \julia{+(a, b)}.

Since broadcasting is so often useful in numerical mathematics,
Julia provides a shorthand notation for it: the instruction \julia{broadcast(welcome, ["Alice", "Bob"])}
can be written compactly as \julia{welcome.(["Alice", "Bob"])}.
Likewise, the line \julia{broadcast(+, 1, [1, 2, 3])} can be shortened to \julia{+.(1, [1, 2, 3])},
or to the more readable expression \julia{1 .+ [1, 2, 3]}.

\begin{task}
    Explain in words what the following instructions do.
    \begin{minted}{julia}
    reshape(1:9, 3, 3) .* [1 2 3]
    reshape(1:9, 3, 3) .* [1; 2; 3]
    reshape(1:9, 3, 3) * [1; 2; 3]
    \end{minted}
\end{task}

\begin{task}
    Given that \julia{string(s1, s2, ...)} enables to convert the arguments to strings and concatenate them,
    what does the following expression do?
    \begin{minted}{julia}
    string.(1:3, ". ", ["First", "Second", "Third"])
    \end{minted}
\end{task}
